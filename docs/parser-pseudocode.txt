Select_Rn =  [T_Id , T_Int, T_Str, T_true, T_false, T_nil, T_Lparen, T_dummy]

//In Rn does not build a tree just puts into the stack ? --not sure
//Reading the semi colan is not properly done in the code

Proc Rn;
    If (Next_Token == T_id or T_Int or T_Str)
        Read(Next_Token)

    elif: (Next_Token == T_true)
          Read(T_true)
          Build_tree('true', 0) 
    elif: (Next_Token == T_false)   
            Read(T_false)
            Build_tree('false', 0)
    elif: (Next_Token == T_nil)
            Read(T_nil)
            Build_tree('nil', 0)
    elif: (Next_Token == T_('E))
            Read(T_('E))
    elif (Next_Token == T_dummy)
            Read(T_dummy)
            Build_tree('dummy', 0)
    else:
        Error;
    End;
End;

Proc R:
    N = 1
    Rn();
    Read (T_;)
    while(Next_Token in Select_Rn):
        Rn();
        N++; 
    else: 
        Error;
    End;
    Build_tree('gamma', N);
End;

Proc Ap:
    R()
    N = 1
    While (Next_Token == T_@):
        Read(T_@)
        Read(T_ID)
        R()
        Build_tree('@', 3)
    End;
End;

Proc Af:
    Ap()
    While (Next_Token == T_**):
        Read(T_**)
        Af()
        Build_tree('**', 2)
    End;
End;

Proc At:
    Af()
    While(Next_Token == T_//):
        Read(T_//)
        Af()
        Build_tree('*', 2)
    While(Next_Token == T_*):
        Read(T_*)
        Af()
        Build_tree('*', 2)
    End;
End;

proc A:
    case Next_Token_of
        T_+: Read(T_+)
             At()
        T_-: Read(T_-)
            Build_tree('Neg', 1)
            At();
        else: At()
              while(Next_Token == T_+)
                    Read(T_+)
                    Build_tree('+',2)
                    At()
              end;
              while(Next_token == T_-)
                    Read(T_-)
                    Build_tree('-',2)
                    At()
              end;

proc Bp: 
    A();
    case Next_Token_of
        (T_gr) or (T_>):Read(T_gr)
                        A()
                        Build_tree('gr', 2)
        (T_ge) or (T_>=): Read(T_ge)
                        A()
                        Build_tree('ge', 2)
        (T_ls) or (T_<): Read(T_ls)  
                        A()
                        Build_tree('ls', 2)
        (T_le) or (T_<=): Read(T_le)
                        A()
                        Build_tree('le', 2)
        (T_eq):Read(T_eq)
                A()
                Build_tree('eq', 2)     \
        (T_ne):Read(T_ne)
               A()
               Build_tree('ne', 2)

    Read('T_;')
End;


proc Bs:
    Bp();
    case Next_Token_of
        (T_not): Read(T_not)
                Build_tree('not', 1)
    Read(T_;);
End;

proc Bt:
    Bs()
    while (Next_Token == T_&)
        Read(T_&)
        Bs()
        Build_tree('&', 2)
    End; 
End;

proc B:
    Bt()
    while(Next_Token == T_or):
        Read(T_or)
        Bt();
        Build_tree('or', 2)
    End;
End;    

proc Tc:
    B()
    N = 1;
    M = 1;
    while(Next_Token == T_->):
        Read(T_->)
        B()
        N++;
    Build_tree('->', N)
    while(Next_Token == T_|)
        Read(T_|)
        B()
        M++;
    Build_tree('|', M)
    End;
End;

proc Ta:
    Tc()
    while(Next_Token == T_aug):
        Read(T_aug)
        Tc()
        Build_tree('aug', 2)
    End;
End;

proc T:
    Ta()
    while(Next_Token == T_,):
        Read(T_,)
        Ta()
        Build_tree('tau', 2)
    End;
End;

proc Ew:
    T();
    if (Next_Token == T_where):
        Read(T_where)
        Dr();
        Build_tree('where', 2)
    else:
        Error;
End;

proc E:
    if(Next_token == T_let):
        Read(T_let)
        D()
        Read(T_in)
        E()
        Build_tree('let', 2)
    elif(Next_Token = T_fn):
        Read(T_fn)
        Read(T_ID)
        Read(T_.)
        E();
        E()
        Build_tree('lambda', 2)
    else:
        Ew()
    End;


    


    






             