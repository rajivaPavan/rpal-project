First =  [T_Id , T_Int, T_Str, T_Lparen]

//In Rn does not build a tree just puts into the stack ? --not sure
//Reading the semi colan is not properly done in the code

Proc Rn;
	If Next_Token is in Select_Rn:
		Read(Next_Token)
	else:
		Error;
	End;
End;


Proc R:
    N = 1
    Rn();
    Read_semi_colon();
    while(Next_Token in First_Rn):
        Rn();
        N++; 
    End;
    Build_tree('gamma', N);
End;

Proc Ap:
    R()
    Read_semi_colon()
    N = 1
    While (Next_Token == T_@):
        Read(T_@, ignore)
        Read(T_ID)
        R()
        Build_tree('@', 3)
    End;
End;

Proc Af:
    Ap()
    if Next_Token == ";" then
        Read_semi_colon()
    else if Next_Token == "**" then
        Read(T_**)
        Af()
        Build_tree('**', 2)
    else 
        Error
    end;
End;

Proc At:
    Af()
    While(Next_Token == T_// or Next_Token == T_*):
        if Next_Token == T_//:
            Read(T_//, ignore)
            Af()
            Build_tree('*', 2)
        if (Next_Token == T_*):
            Read(T_*, ignore)
            Af()
            Build_tree('*', 2)
    End;
End;

------------------------------------

A -> (At; | +At | -At) ( ('+' At) | ('-' At) )+

// above is kind of like an regular expression for the procedure A

// below code is incorrect, python code is implemented according to the above regular expression
proc A:
    case Next_Token_of
        T_+: Read(T_+)
             At()
        T_-: Read(T_-)
            At();
            Build_tree('Neg', 1)
        otherwise: 
            At()
            while(Next_Token == T_+)
                    Read(T_+)
                    Build_tree('+',2)
                    At()
            end;
            while(Next_token == T_-)
                    Read(T_-)
                    Build_tree('-',2)
                    At()
            end;
---------------------------------------------------
proc Bp: 
    A();
    case Next_Token_of
        (T_gr) or (T_>):Read(T_gr)
                        A()
                        Build_tree('gr', 2)
        (T_ge) or (T_>=): Read(T_ge)
                        A()
                        Build_tree('ge', 2)
        (T_ls) or (T_<): Read(T_ls)  
                        A()
                        Build_tree('ls', 2)
        (T_le) or (T_<=): Read(T_le)
                        A()
                        Build_tree('le', 2)
        (T_eq):Read(T_eq)
                A()
                Build_tree('eq', 2)     \
        (T_ne):Read(T_ne)
               A()
               Build_tree('ne', 2)
        (T_;):Read('T_;')
        otherwise: Error
End;


proc Bs:
    if Next_Token == T_not:
        Read(T_not)
        Bp()
        Build_tree('not', 1)
    else:
        Bp()
        Read_semi_colon()
End;

proc Bt:
    Bs()
    Read_semi_colon()
    while (Next_Token == T_&)
        Read(T_&)
        Bs()
        Build_tree('&', 2)
    End; 
End;

proc B:
    Bt()
    Read_semi_colon()
    while(Next_Token == T_or):
        Read(T_or)
        Bt();
        Build_tree('or', 2)
    End;
End;    

// this is incorrect - check the python code
proc Tc:
    B()
    N = 1;
    M = 1;
    while(Next_Token == T_->):
        Read(T_->)
        B()
        N++;
    Build_tree('->', N)
    while(Next_Token == T_|)
        Read(T_|)
        B()
        M++;
    Build_tree('|', M)
    End;
End;



    


    






             